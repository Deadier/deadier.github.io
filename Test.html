<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <title>ANFR – Compteur pylônes & antennes (Explore v2.1)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root { --pad:.5rem; --bd:#ddd; --muted:#666; --ok:#116611; --warn:#995500; --err:#992222; }
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; line-height:1.45; margin: 2rem; }
    h1 { margin-top:0 }
    label { display:block; margin-top:.4rem; }
    input, select, button { font-size:1rem; padding:.35rem .5rem; }
    .row { display:flex; gap:1rem; flex-wrap:wrap; align-items:flex-end; margin:.5rem 0 1rem; }
    table { border-collapse:collapse; width:100%; max-width:1100px; margin-top:1rem; }
    th, td { border:1px solid var(--bd); padding:.4rem .5rem; text-align:right; }
    th:first-child, td:first-child { text-align:left; }
    tfoot td { font-weight:700; }
    .muted { color:var(--muted); font-size:.92rem; }
    .ok { color:var(--ok); } .warn { color:var(--warn); } .error { color:var(--err); }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; }
    .small { font-size:.9rem; }
  </style>
</head>
<body>
  <h1>Compter pylônes et antennes par opérateur (ANFR / Explore v2.1)</h1>

  <div class="row">
    <label>Latitude<br><input id="lat" type="number" step="any" value="48.8566"></label>
    <label>Longitude<br><input id="lon" type="number" step="any" value="2.3522"></label>
    <label>Rayon (mètres)<br><input id="radius" type="number" step="1" value="2500"></label>
    <label>Région<br>
      <select id="region">
        <option value="metropole" selected>métropole</option>
        <option value="antilles">antilles-guyane</option>
      </select>
    </label>
    <button id="run">Calculer</button>
    <button id="openMap">Ouvrir la carte ANFR</button>
  </div>

  <div id="meta" class="muted">Chargement du schéma du jeu de données…</div>

  <table id="tbl">
    <thead>
      <tr>
        <th>opérateur</th>
        <th>pylônes (supports) uniques</th>
        <th>2G</th><th>3G</th><th>4G</th><th>5G</th>
        <th>total antennes</th>
      </tr>
    </thead>
    <tbody id="body"></tbody>
    <tfoot>
      <tr>
        <td>tous opérateurs</td>
        <td id="sumPylons">–</td>
        <td id="sum2g">–</td><td id="sum3g">–</td><td id="sum4g">–</td><td id="sum5g">–</td>
        <td id="sumAllAnt">–</td>
      </tr>
    </tfoot>
  </table>

  <p class="muted small">
    Source : jeu <span class="mono">observatoire_2g_3g_4g</span> – ANFR. Statuts pris en compte : <em>En service</em> (2G/3G/4G) et
    <em>Techniquement opérationnel</em> (5G). Filtre géographique : cercle via <span class="mono">within_distance()</span>.
  </p>

<script>
(async () => {
  // --- constantes de domaine/dataset (Explore v2.1)
  const DATASET = "observatoire_2g_3g_4g";
  const BASE   = `https://data.anfr.fr/api/explore/v2.1/catalog/datasets/${DATASET}/records`;
  const INFO   = `https://data.anfr.fr/api/explore/v2.1/catalog/datasets/${DATASET}`;

  // opérateurs par zone (libellés tels qu’ils apparaissent dans les facettes ANFR)
  const OPS_METRO = ["ORANGE","BOUYGUES TELECOM","SFR","FREE MOBILE"];
  const OPS_ANTIL = ["ORANGE","FREE CARAIBES","DIGICEL","OUTREMER TELECOM"];

  // champs (détectés dynamiquement, avec replis prudents)
  let GEO_FIELD = "geo_point_2d";
  let FIELD_SUPPORT = "sup_id";          // identifiant de support (pylône)
  let FIELD_OPERATEUR = "adm_lb_nom";    // libellé opérateur
  let FIELD_GENERATION = "generation";   // 2G / 3G / 4G / 5G
  let FIELD_STATUT = "statut";           // En service / Techniquement opérationnel
  let lastUpdated = null;

  // utilitaire fetch JSON
  async function fetchJSON(url) {
    const r = await fetch(url);
    if (!r.ok) throw new Error(`HTTP ${r.status} sur ${url}`);
    return r.json();
  }

  // détecte automatiquement les noms de champs (insensible à la casse) + champ géo + date MAJ
  async function detectSchema() {
    try {
      const j = await fetchJSON(INFO);
      const fields = j?.dataset?.schema?.fields || [];
      const metas = j?.dataset?.metas || {};
      lastUpdated = metas?.data_processed || metas?.modified || null;

      const byName = (nameList) => {
        // renvoie le premier champ dont le nom (lowercase) matche l’un des candidats
        const cand = nameList.map(s => s.toLowerCase());
        const f = fields.find(f => cand.includes(String(f.name||"").toLowerCase()));
        return f?.name || null;
      };

      GEO_FIELD       = byName(["geo_point_2d","geo_shape","geopoint","geom"]) || GEO_FIELD;
      FIELD_SUPPORT   = byName(["sup_id","SUP_ID","support_id"]) || FIELD_SUPPORT;
      FIELD_OPERATEUR = byName(["adm_lb_nom","operateur","opérateur","operator"]) || FIELD_OPERATEUR;
      FIELD_GENERATION= byName(["generation","génération"]) || FIELD_GENERATION;
      FIELD_STATUT    = byName(["statut","status"]) || FIELD_STATUT;

      document.getElementById("meta").innerHTML =
        `Champ géographique : <span class="mono ok">${GEO_FIELD}</span> · `+
        `champs → opérateur=<span class="mono">${FIELD_OPERATEUR}</span>, `+
        `génération=<span class="mono">${FIELD_GENERATION}</span>, `+
        `statut=<span class="mono">${FIELD_STATUT}</span>, `+
        `support=<span class="mono">${FIELD_SUPPORT}</span>` +
        (lastUpdated ? ` — dernière mise à jour : <span class="mono">${lastUpdated}</span>` : "");
    } catch (e) {
      document.getElementById("meta").innerHTML =
        `Impossible de lire le schéma du dataset (replis utilisés).`;
    }
  }

  // construction de l’expression WHERE
  function whereExpr({lat,lon,radius, operateur=null}) {
    const wkt = `POINT(${lon} ${lat})`;
    const parts = [
      `within_distance(${GEO_FIELD}, GEOM'${wkt}', ${radius} m)`,
      `${FIELD_STATUT} IN ("En service","Techniquement opérationnel")`
    ];
    if (operateur) {
      // valeur protégée (guillemet + échappement)
      const v = operateur.replaceAll('"','\\"');
      parts.push(`${FIELD_OPERATEUR} = "${v}"`);
    }
    return parts.join(" AND ");
  }

  // utilitaire URL Explore v2.1
  function buildURL(params) {
    const p = new URLSearchParams();
    for (const [k,v] of Object.entries(params)) {
      if (v == null) continue;
      if (Array.isArray(v)) v.forEach(x => p.append(k, x));
      else p.set(k, v);
    }
    return `${BASE}?${p.toString()}`;
  }

  // antennes par génération pour un opérateur (agrégation côté serveur)
  async function countsByGeneration(op, lat, lon, radius) {
    const url = buildURL({
      select: `${FIELD_GENERATION}, count(1) as n`,
      where: whereExpr({lat, lon, radius, operateur: op}),
      "group_by": FIELD_GENERATION,
      limit: "10", // group_by → limite max 20000 d’après la doc
      lang: "fr"
    });
    const data = await fetchJSON(url);
    return data?.results || [];
  }

  // pylônes uniques (supports) pour un opérateur (count distinct approximatif côté serveur)
  async function countDistinctPylons(op, lat, lon, radius) {
    const url = buildURL({
      select: `count(distinct(${FIELD_SUPPORT})) as pylones`,
      where: whereExpr({lat, lon, radius, operateur: op}),
      limit: "1",
      lang: "fr"
    });
    const data = await fetchJSON(url);
    return Number(data?.results?.[0]?.pylones ?? 0);
  }

  // pylônes uniques tous opérateurs
  async function countAllPylons(lat, lon, radius) {
    const url = buildURL({
      select: `count(distinct(${FIELD_SUPPORT})) as pylones`,
      where: whereExpr({lat, lon, radius}),
      limit: "1",
      lang: "fr"
    });
    const data = await fetchJSON(url);
    return Number(data?.results?.[0]?.pylones ?? 0);
  }

  // transforme la liste groupée en ligne normalisée
  function toRow(operator, groups) {
    const M = new Map(groups.map(g => [String(g[FIELD_GENERATION]).toUpperCase(), Number(g.n)]));
    const g2 = M.get("2G") || 0, g3 = M.get("3G") || 0, g4 = M.get("4G") || 0, g5 = M.get("5G") || 0;
    return { operator, g2, g3, g4, g5, total: g2+g3+g4+g5 };
  }

  // exécution principale
  async function run() {
    const lat = Number(document.getElementById("lat").value);
    const lon = Number(document.getElementById("lon").value);
    const radius = Math.max(1, Number(document.getElementById("radius").value|0));
    const region = document.getElementById("region").value;
    const ops = (region === "antilles") ? OPS_ANTIL : OPS_METRO;

    const tbody = document.getElementById("body");
    tbody.innerHTML = `<tr><td colspan="7" class="muted">Calcul en cours…</td></tr>`;

    try {
      // 2 appels par opérateur (group_by + distinct supports) en parallèle
      const rows = await Promise.all(ops.map(async op => {
        const [groups, pylones] = await Promise.all([
          countsByGeneration(op, lat, lon, radius),
          countDistinctPylons(op, lat, lon, radius)
        ]);
        const row = toRow(op, groups);
        row.pylones = pylones;
        return row;
      }));

      // rendu
      tbody.innerHTML = rows.map(r => `
        <tr>
          <td>${r.operator}</td>
          <td>${r.pylones.toLocaleString('fr-FR')}</td>
          <td>${r.g2.toLocaleString('fr-FR')}</td>
          <td>${r.g3.toLocaleString('fr-FR')}</td>
          <td>${r.g4.toLocaleString('fr-FR')}</td>
          <td>${r.g5.toLocaleString('fr-FR')}</td>
          <td>${r.total.toLocaleString('fr-FR')}</td>
        </tr>
      `).join("");

      // totaux (antennes = somme, pylônes = calcul global côté serveur)
      const sum = rows.reduce((a, r) => ({
        pyl: a.pyl + r.pylones, g2:a.g2+r.g2, g3:a.g3+r.g3, g4:a.g4+r.g4, g5:a.g5+r.g5, tot:a.tot+r.total
      }), {pyl:0,g2:0,g3:0,g4:0,g5:0,tot:0});

      document.getElementById("sumPylons").textContent = (await countAllPylons(lat, lon, radius)).toLocaleString('fr-FR');
      document.getElementById("sum2g").textContent = sum.g2.toLocaleString('fr-FR');
      document.getElementById("sum3g").textContent = sum.g3.toLocaleString('fr-FR');
      document.getElementById("sum4g").textContent = sum.g4.toLocaleString('fr-FR');
      document.getElementById("sum5g").textContent = sum.g5.toLocaleString('fr-FR');
      document.getElementById("sumAllAnt").textContent = sum.tot.toLocaleString('fr-FR');

    } catch (e) {
      tbody.innerHTML = `<tr><td colspan="7" class="error">Erreur : ${e.message}</td></tr>`;
    }
  }

  // lien « frame map » ANFR (centrage + rayon + statuts actifs)
  function openMap() {
    const lat = Number(document.getElementById("lat").value);
    const lon = Number(document.getElementById("lon").value);
    const radius = Math.max(1, Number(document.getElementById("radius").value|0));
    const url = new URL("https://data.anfr.fr/visualisation/frame/map/");
    url.searchParams.set("id", DATASET);
    // on suggère visuellement les deux statuts actifs
    url.searchParams.append("refine.statut", "En service");
    url.searchParams.append("refine.statut", "Techniquement opérationnel");
    url.searchParams.set("geofilter.distance", `${lat},${lon},${radius}`);
    url.searchParams.set("location", `12,${lat},${lon}`);
    window.open(url.toString(), "_blank");
  }

  await detectSchema();
  document.getElementById("run").addEventListener("click", run);
  document.getElementById("openMap").addEventListener("click", openMap);
})();
</script>
</body>
</html>

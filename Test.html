<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Observatoire ANFR – Comptage optimisé (facettes)</title>
  <style>
    :root{
      --bg:#0f172a; /* slate-900 */
      --panel:#111827; /* gray-900 */
      --muted:#94a3b8; /* slate-400 */
      --fg:#e5e7eb; /* gray-200 */
      --accent:#22c55e; /* green-500 */
      --danger:#ef4444; /* red-500 */
      --card:#111827;
      --border:#1f2937; /* gray-800 */
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0; font:16px/1.45 system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,"Helvetica Neue",Arial;
      color:var(--fg); background:linear-gradient(180deg, var(--bg), #030712 60%);
    }
    header{padding:24px 16px 8px; max-width:1200px; margin:0 auto}
    h1{margin:0 0 6px; font-size:22px; font-weight:700}
    p.lead{margin:0; color:var(--muted)}
    main{max-width:1200px; margin:16px auto; padding:0 16px}
    .panel{background:var(--panel); border:1px solid var(--border); border-radius:14px; padding:16px; box-shadow:0 10px 20px rgba(0,0,0,.35)}
    .grid{display:grid; grid-template-columns:1.2fr .8fr; gap:16px}
    @media (max-width:1000px){ .grid{grid-template-columns:1fr} }

    label{display:block; font-weight:600; margin:8px 0 4px}
    input[type="number"], input[type="text"], select{
      width:100%; padding:10px 12px; border-radius:10px; border:1px solid var(--border); background:#0b1220; color:var(--fg);
    }
    .row{display:grid; grid-template-columns:repeat(3,1fr); gap:12px}
    .row-2{display:grid; grid-template-columns:1fr 1fr; gap:12px}
    @media (max-width:760px){ .row{grid-template-columns:1fr} .row-2{grid-template-columns:1fr}}

    .btns{display:flex; flex-wrap:wrap; gap:10px; margin-top:12px}
    button, a.btn{
      appearance:none; border:1px solid var(--border); background:#0b1220; color:var(--fg);
      padding:10px 14px; border-radius:10px; cursor:pointer; font-weight:600;
    }
    button.primary{background:var(--accent); color:#04130b; border-color:#0f5132}
    button.ghost{background:transparent}
    button:disabled{opacity:.6; cursor:not-allowed}

    .status{margin-top:10px; min-height:24px; color:var(--muted)}
    .error{color:var(--danger)}

    table{width:100%; border-collapse:collapse; overflow:auto; border-radius:12px; border:1px solid var(--border)}
    th,td{padding:10px 12px; border-bottom:1px solid var(--border); text-align:right}
    th:first-child, td:first-child{text-align:left}
    thead th{position:sticky; top:0; background:#0d1322}
    tfoot td{font-weight:700}

    .badge{display:inline-block; padding:2px 8px; border-radius:999px; border:1px solid var(--border); color:var(--muted); font-size:12px}
    .kpi{display:grid; grid-template-columns:repeat(3,1fr); gap:12px; margin:12px 0}
    .kpi .card{background:var(--card); border:1px solid var(--border); border-radius:12px; padding:14px}
    .kpi .card h3{margin:0; font-size:13px; color:var(--muted); font-weight:600}
    .kpi .card p{margin:6px 0 0; font-size:20px; font-weight:800}

    iframe{width:100%; height:540px; border:1px solid var(--border); border-radius:12px}
    .muted{color:var(--muted)}
    .small{font-size:12px}
    .spinner{display:inline-block; width:16px; height:16px; border:2px solid #2e374b; border-top-color:var(--accent); border-radius:50%; animation:spin 1s linear infinite}
    @keyframes spin{to{transform:rotate(360deg)}}
    code{background:#0b1220; border:1px solid var(--border); border-radius:8px; padding:2px 6px}
  </style>
</head>
<body>
  <header>
    <h1>ANFR – Comptage optimisé des antennes et pylônes (facettes)</h1>
    <p class="lead">Basé sur <span class="badge">/d4c/api/records/1.0/search/</span> – jeu de données <code>observatoire_2g_3g_4g</code>.</p>
  </header>

  <main class="grid">
    <section class="panel">
      <h2 style="margin-top:0">Paramètres</h2>
      <div class="row">
        <div>
          <label for="lat">latitude</label>
          <input id="lat" type="number" step="0.000001" placeholder="48.8566" value="45.770342" />
        </div>
        <div>
          <label for="lon">longitude</label>
          <input id="lon" type="number" step="0.000001" placeholder="2.3522" value="4.774298" />
        </div>
        <div>
          <label for="radius">rayon (m)</label>
          <input id="radius" type="number" step="10" placeholder="2500" value="2500" />
        </div>
      </div>
      <div class="row-2" style="margin-top:8px">
        <div>
          <label for="method">méthode de comptage des pylônes</label>
          <select id="method">
            <option value="facets" selected>facettes (rapide)</option>
            <option value="dedup">dédoublonnage sup_id (plus fiable si zone immense)</option>
          </select>
          <p class="small muted" style="margin:6px 0 0">Les totaux « antennes » sont toujours calculés par facette <code>generation</code>. Les « pylônes » utilisent par défaut la facette <code>sup_id</code>.</p>
          <label style="margin-top:12px; display:flex; align-items:center; gap:8px">
            <input id="forceJsonp" type="checkbox" /> Forcer le mode JSONP (contourne CORS)
          </label>
          <label style="margin-top:8px; display:flex; align-items:center; gap:8px">
            <input id="usePublicProxies" type="checkbox" /> Essayer des proxys publics si JSONP échoue (non recommandé en production)
          </label>
          <label style="margin-top:8px">
            proxy personnalisé (préfixe d’URL)&nbsp;
            <input id="customProxy" type="text" placeholder="https://votre-proxy.exemple/fetch/" />
            <span class="small muted">Laissez vide pour ne pas l’utiliser.</span>
          </label>
        </div>
        <div>
          <label>&nbsp;</label>
          <div class="btns">
            <button id="run" class="primary">Analyser</button>
            <button id="showMap">Afficher la carte</button>
            <button id="meta" class="ghost">Métadonnées du jeu</button>
            <button id="tests" class="ghost">Tests</button>
          </div>
        </div>
      </div>
      <div class="status" id="status"></div>
    </section>

    <section class="panel">
      <h2 style="margin-top:0">Carte</h2>
      <iframe id="map" title="Carte ANFR"></iframe>
      <p class="small muted">La carte est un <em>iframe</em> officiel ANFR filtré sur le disque (latitude, longitude, rayon) et les statuts « En service » et « Techniquement opérationnel ».</p>
    </section>

    <section class="panel" style="grid-column:1/-1">
      <h2 style="margin-top:0">Résultats</h2>
      <div class="kpi">
        <div class="card"><h3>opérateurs détectés</h3><p id="kpiOps">—</p></div>
        <div class="card"><h3>pylônes (tous opérateurs)</h3><p id="kpiPylAll">—</p></div>
        <div class="card"><h3>antennes (tous opérateurs)</h3><p id="kpiAntAll">—</p></div>
      </div>
      <div style="overflow:auto">
        <table id="tbl">
          <thead>
            <tr>
              <th>opérateur</th>
              <th>2G</th>
              <th>3G</th>
              <th>4G</th>
              <th>5G</th>
              <th>antennes</th>
              <th>pylônes</th>
            </tr>
          </thead>
          <tbody></tbody>
          <tfoot>
            <tr>
              <td>total</td>
              <td id="t2g">0</td>
              <td id="t3g">0</td>
              <td id="t4g">0</td>
              <td id="t5g">0</td>
              <td id="tant">0</td>
              <td id="tpyl">0</td>
            </tr>
          </tfoot>
        </table>
      </div>
    </section>

    <section class="panel" style="grid-column:1/-1">
      <h2 style="margin-top:0">Journal</h2>
      <pre id="log" style="white-space:pre-wrap; background:#0b1220; border:1px solid var(--border); padding:12px; border-radius:12px; max-height:260px; overflow:auto"></pre>
    </section>
  </main>

  <script>
  (function(){
    const API_BASE = "https://data.anfr.fr/d4c/api/records/1.0/search/"; // 1.0 pour geofilter.distance + facettes
    const DATASET = "observatoire_2g_3g_4g";
    const STATUS_FILTERS = ["En service", "Techniquement opérationnel"]; // 2G/3G/4G + 5G

    const DISPLAY_LABEL = {
      "ORANGE":"Orange",
      "SFR":"SFR",
      "BOUYGUES TELECOM":"Bouygues Telecom",
      "FREE MOBILE":"Free Mobile",
      "OUTREMER TELECOM":"SFR Caraïbes (OUTREMER TELECOM)",
      "FREE CARAIBES":"Free Caraïbes",
      "DIGICEL":"Digicel"
    };

    const PUBLIC_PROXIES = [
      u => `https://cors.isomorphic-git.org/${u}`,
      u => `https://api.allorigins.win/raw?url=${encodeURIComponent(u)}`,
      u => `https://thingproxy.freeboard.io/fetch/${u}`
    ];

    const $ = (id)=>document.getElementById(id);
    const log = (msg)=>{$("log").textContent += msg+"\n"};

    function setStatus(text, isError=false){
      const el=$("status");
      el.innerHTML = isError ? `<span class="error">${text}</span>` : text;
    }

    function validCoords(lat, lon){
      return isFinite(lat) && isFinite(lon) && Math.abs(lat) <= 90 && Math.abs(lon) <= 180;
    }

    function zoomFromRadius(r){
      if (r <= 300) return 17;
      if (r <= 600) return 16;
      if (r <= 1000) return 15;
      if (r <= 2500) return 14;
      if (r <= 5000) return 13;
      if (r <= 10000) return 12;
      if (r <= 25000) return 11;
      if (r <= 50000) return 10;
      if (r <= 100000) return 9;
      return 8;
    }

    function mapUrl(lat, lon, r){
      const zoom = zoomFromRadius(r);
      const usp = new URLSearchParams();
      usp.set("id", DATASET);
      for(const s of STATUS_FILTERS){ usp.append("refine.statut", s); }
      usp.set("geofilter.distance", `${lat},${lon},${r}`);
      usp.set("datasetcard", "true");
      usp.set("scrollWheelZoom", "true");
      usp.set("location", `${zoom},${lat},${lon}`);
      return `https://data.anfr.fr/visualisation/frame/map/?${usp.toString()}`;
    }

    function buildParams(base={}){
      const usp = new URLSearchParams({ dataset: DATASET, rows: String(base.rows ?? 0) });
      if(base.facets){ for(const f of base.facets) usp.append("facet", f); }
      if(base.adm){ usp.append("refine.adm_lb_nom", base.adm); }
      if(base.generation){ usp.append("refine.generation", base.generation); }
      if(base.distance){ usp.append("geofilter.distance", base.distance); }
      for(const s of STATUS_FILTERS){ usp.append("refine.statut", s); }
      if(base.start != null){ usp.set("start", String(base.start)); }
      if(base.rows != null){ usp.set("rows", String(base.rows)); }
      return usp;
    }

    // --- Outils réseau ---
    function mkJsonpUrl(url, cbParam, cbName){
      const sep = url.includes("?") ? "&" : "?";
      return url + sep + encodeURIComponent(cbParam) + "=" + encodeURIComponent(cbName);
    }

    function jsonpOnce(url, cbParam){
      return new Promise((resolve, reject)=>{
        const cb = "jsonp_cb_" + Math.random().toString(36).slice(2);
        const s = document.createElement("script");
        const timer = setTimeout(()=>{ cleanup(); reject(new Error("JSONP timeout")); }, 15000);
        function cleanup(){
          clearTimeout(timer);
          delete window[cb];
          if(s.parentNode) s.parentNode.removeChild(s);
        }
        window[cb] = (data)=>{ cleanup(); resolve(data); };
        s.onerror = ()=>{ cleanup(); reject(new Error("JSONP load error")); };
        s.src = mkJsonpUrl(url, cbParam, cb);
        document.body.appendChild(s);
      });
    }

    async function jsonp(url){
      // Essaie d'abord ?callback=, puis ?jsonp=
      try{ return await jsonpOnce(url, "callback"); }
      catch(e1){ log("⚠ JSONP with ?callback a échoué ("+e1.message+")"); }
      return jsonpOnce(url, "jsonp");
    }

    async function fetchViaProxies(url){
      const custom = $("customProxy").value.trim();
      const candidates = [];
      if(custom){
        const normalized = custom.endsWith("/") ? custom : custom + "/";
        candidates.push((u)=> normalized + u);
      }
      if($("usePublicProxies").checked){
        candidates.push(...PUBLIC_PROXIES);
      }
      for(const fn of candidates){
        const proxied = fn(url);
        try{
          log("→ tentative via proxy : "+proxied);
          const res = await fetch(proxied, { cache:"no-store" });
          if(!res.ok) throw new Error("HTTP "+res.status);
          // Certaines passerelles renvoient text/plain
          const text = await res.text();
          const data = JSON.parse(text);
          return data;
        }catch(err){
          log("⚠ proxy KO : "+err.message);
        }
      }
      throw new Error("Aucun proxy n'a fonctionné");
    }

    async function fetchJson(url){
      // 1) essai direct CORS
      try{
        const res = await fetch(url, { mode:"cors", cache:"no-store" });
        if(!res.ok) throw new Error(`HTTP ${res.status} – ${res.statusText}`);
        return await res.json();
      }catch(err1){
        log("⚠ fetch CORS a échoué ("+err1.message+")");
      }
      // 2) forcé JSONP via UI ou fallback
      try{
        if($("forceJsonp").checked){ log("⚠ mode forcé JSONP activé"); }
        return await jsonp(url);
      }catch(err2){
        log("⚠ JSONP a échoué ("+err2.message+")");
      }
      // 3) proxys si demandés
      if($("usePublicProxies").checked || $("customProxy").value.trim()){
        try{ return await fetchViaProxies(url); }
        catch(err3){ log("⚠ proxys indisponibles ("+err3.message+")"); }
      }
      // 4) échec total
      throw new Error("Impossible de récupérer les données (CORS/JSONP/Proxy)");
    }

    function getFacet(groups, name){
      const g = (groups || []).find(x => x.name === name);
      return g ? (g.facets || []) : [];
    }

    function facetsToMap(facets){
      const m = Object.create(null);
      for(const it of facets){ m[it.name] = it.count; }
      return m;
    }

    async function getOperatorsInArea(lat, lon, r){
      const p = buildParams({ facets:["adm_lb_nom"], rows:0, distance:`${lat},${lon},${r}` });
      const url = `${API_BASE}?${p.toString()}`;
      log("→ opérateurs présents : "+url);
      const data = await fetchJson(url);
      const ops = getFacet(data.facet_groups, "adm_lb_nom").map(f=>({ name:f.name, count:f.count }))
                       .sort((a,b)=>b.count-a.count);
      return ops;
    }

    async function getStatsForOperator(lat, lon, r, operator, method){
      const p = buildParams({ facets:["generation","sup_id"], rows:0, distance:`${lat},${lon},${r}`, adm:operator });
      const url = `${API_BASE}?${p.toString()}`;
      log("→ stats opérateur (facettes) : "+url);
      const data = await fetchJson(url);

      const genFacet = facetsToMap(getFacet(data.facet_groups, "generation"));
      const antennes = (genFacet["2G"]||0)+(genFacet["3G"]||0)+(genFacet["4G"]||0)+(genFacet["5G"]||0);
      let pylones = getFacet(data.facet_groups, "sup_id").length; // valeurs distinctes

      if(method === "dedup"){
        pylones = await countSupportsByDedup(lat, lon, r, operator);
      }

      return { operator, gen:genFacet, antennes, pylones };
    }

    async function getAllPylones(lat, lon, r, method){
      if(method === "dedup"){ return countSupportsByDedup(lat, lon, r, null); }
      const p = buildParams({ facets:["sup_id"], rows:0, distance:`${lat},${lon},${r}` });
      const url = `${API_BASE}?${p.toString()}`;
      log("→ pylônes (tous opérateurs, facette sup_id) : "+url);
      const data = await fetchJson(url);
      return getFacet(data.facet_groups, "sup_id").length;
    }

    async function countSupportsByDedup(lat, lon, r, operator){
      // Pagination 1.0 (pas de 'fields' ni 'records_format' en 1.0)
      const rows = 1000; let start = 0; const supports = new Set();
      while(start < 10000){
        const p = buildParams({ distance:`${lat},${lon},${r}`, rows, start });
        if(operator){ p.append("refine.adm_lb_nom", operator); }
        const url = `${API_BASE}?${p.toString()}`;
        log("→ page supports (dédoublonnage) : "+url);
        const data = await fetchJson(url);
        const recs = Array.isArray(data.records) ? data.records : [];
        if(recs.length === 0) break;
        for(const rec of recs){
          const sid = rec && rec.fields && rec.fields.sup_id;
          if(sid!=null) supports.add(String(sid));
        }
        if(recs.length < rows) break;
        start += rows;
      }
      return supports.size;
    }

    function fmt(n){ return n.toLocaleString("fr-FR"); }

    function displayResults(opsStats, pylAll){
      const tbody = $("tbl").querySelector("tbody");
      tbody.innerHTML = "";
      let t2=0,t3=0,t4=0,t5=0, tant=0, tpyl=0;
      for(const s of opsStats){
        const g2=s.gen["2G"]||0, g3=s.gen["3G"]||0, g4=s.gen["4G"]||0, g5=s.gen["5G"]||0;
        const tr = document.createElement("tr");
        const label = DISPLAY_LABEL[s.operator] || s.operator;
        tr.innerHTML = `<td>${label}</td>
          <td>${fmt(g2)}</td><td>${fmt(g3)}</td><td>${fmt(g4)}</td><td>${fmt(g5)}</td>
          <td>${fmt(s.antennes)}</td><td>${fmt(s.pylones)}</td>`;
        tbody.appendChild(tr);
        t2+=g2; t3+=g3; t4+=g4; t5+=g5; tant+=s.antennes; tpyl+=s.pylones;
      }
      $("t2g").textContent = fmt(t2);
      $("t3g").textContent = fmt(t3);
      $("t4g").textContent = fmt(t4);
      $("t5g").textContent = fmt(t5);
      $("tant").textContent = fmt(tant);
      $("tpyl").textContent = fmt(tpyl);

      $("kpiOps").textContent = fmt(opsStats.length);
      $("kpiPylAll").textContent = pylAll!=null? fmt(pylAll) : "—";
      $("kpiAntAll").textContent = fmt(tant);
    }

    async function run(){
      const lat = parseFloat($("lat").value);
      const lon = parseFloat($("lon").value);
      const r = parseInt($("radius").value,10);
      const method = $("method").value;
      $("log").textContent = "";

      if(!validCoords(lat,lon) || !(r>0)){
        setStatus("Veuillez renseigner une latitude/longitude valides et un rayon > 0.", true);
        return;
      }

      setStatus(`<span class="spinner"></span> Analyse en cours…`);

      try{
        const ops = await getOperatorsInArea(lat,lon,r);
        if(ops.length===0){
          setStatus("Aucun opérateur détecté dans le disque demandé.");
          displayResults([], 0);
          return;
        }

        // stats par opérateur (petites rafales)
        const pool = 3; const queue = ops.map(o=>o.name); const results = [];
        async function worker(){
          while(queue.length){
            const op = queue.shift();
            try{ results.push(await getStatsForOperator(lat,lon,r,op,method)); }
            catch(e){ log("! échec opérateur "+op+" : "+e.message); }
          }
        }
        await Promise.all(Array.from({length:Math.min(pool, ops.length)}, worker));
        results.sort((a,b)=>b.antennes-a.antennes);

        const pylAll = await getAllPylones(lat,lon,r,method);

        displayResults(results, pylAll);
        setStatus(`Terminé. ${results.length} opérateur(s) analysé(s).`);
        $("map").src = mapUrl(lat,lon,r);
      }catch(err){
        console.error(err);
        setStatus("Erreur : "+err.message, true);
      }
    }

    // --- Jeux de tests unitaires ---
    function runTests(){
      const failures = [];
      // Test 1: buildParams inclut dataset et rows=0 par défaut
      const p1 = buildParams({});
      if(p1.get("dataset") !== DATASET) failures.push("buildParams: dataset manquant");
      if(p1.get("rows") !== "0") failures.push("buildParams: rows par défaut incorrect");
      // Test 2: zoomFromRadius (seuils)
      if(zoomFromRadius(2500) !== 14) failures.push("zoomFromRadius: 2500m devrait donner 14");
      if(zoomFromRadius(75000) !== 9) failures.push("zoomFromRadius: 75km devrait donner 9");
      // Test 3: facetsToMap
      const m = facetsToMap([{name:"2G",count:3},{name:"5G",count:1}]);
      if(!(m["2G"]===3 && m["5G"]===1)) failures.push("facetsToMap: mappage incorrect");
      // Test 4: mkJsonpUrl ajoute bien le paramètre, avec & ou ?
      const uA = mkJsonpUrl("https://x/api", "callback", "cb");
      const uB = mkJsonpUrl("https://x/api?rows=0", "callback", "cb");
      if(!uA.endsWith("callback=cb")) failures.push("mkJsonpUrl: ajout sans query incorrect");
      if(!uB.includes("&callback=cb")) failures.push("mkJsonpUrl: ajout avec query incorrect");
      // Résultat
      if(failures.length){
        log("Tests: ❌ échecs\n - "+failures.join("\n - "));
        alert("Tests: échecs\n"+failures.join("\n"));
      } else {
        log("Tests: ✅ tous les tests passés");
        alert("Tests: tous les tests passés");
      }
    }

    $("run").addEventListener("click", run);
    $("showMap").addEventListener("click", ()=>{
      const lat = parseFloat($("lat").value);
      const lon = parseFloat($("lon").value);
      const r = parseInt($("radius").value,10);
      if(validCoords(lat,lon) && r>0){ $("map").src = mapUrl(lat,lon,r); }
    });

    $("meta").addEventListener("click", ()=>{
      const url = "https://data.anfr.fr/visualisation/information/?id="+DATASET;
      window.open(url, "_blank");
    });

    $("tests").addEventListener("click", runTests);

    // initialiser la carte au chargement
    $("map").src = mapUrl(parseFloat($("lat").value), parseFloat($("lon").value), parseInt($("radius").value,10));
  })();
  </script>
</body>
</html>
